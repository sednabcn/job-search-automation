name: Cleanup Old Workflow Runs
on:
  push:
    branches: ["dev", "master"]
  workflow_dispatch:
jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
      issues: write
    steps:
      - name: Delete old and failed workflow runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const KEEP_RECENT_RUNS = 1;
            const KEEP_DAYS = 0;
            const MAX_PAGES = 100;
            const DELETE_OLD_EVEN_IF_SUCCESSFUL = true;
            console.log(`üßπ Cleaning workflow runs for ${owner}/${repo}`);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);
            const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({ owner, repo });
            const workflows = workflowsData.workflows || [];
            for (const workflow of workflows) {
              console.log(`\nüîç Processing: ${workflow.name} (id=${workflow.id})`);
              let allRuns = [];
              for (let page = 1; page <= MAX_PAGES; page++) {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflow.id,
                  per_page: 100,
                  page
                });
                if (!data.workflow_runs.length) break;
                allRuns = allRuns.concat(data.workflow_runs);
              }
              if (!allRuns.length) {
                console.log("  ‚ö†Ô∏è No runs found.");
                continue;
              }
              allRuns.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const runsToKeep = allRuns.slice(0, KEEP_RECENT_RUNS);
              const runsToDelete = [];
              for (const run of allRuns.slice(KEEP_RECENT_RUNS)) {
                const runDate = new Date(run.created_at);
                const isOld = runDate < cutoffDate;
                const isFailed = run.conclusion && run.conclusion !== 'success';
                const isCurrent = run.id === context.runId;
                if (isCurrent) {
                  console.log(`  ‚è≠Ô∏è Skipping current cleanup run (${run.id})`);
                  continue;
                }
                if (isOld && (isFailed || DELETE_OLD_EVEN_IF_SUCCESSFUL)) {
                  runsToDelete.push(run);
                }
              }
              console.log(`  üìä Found ${allRuns.length} total runs (${runsToDelete.length} deletable)`);
              for (const run of runsToDelete) {
                try {
                  await github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id });
                  console.log(`  üóëÔ∏è Deleted run ${run.id} (${run.conclusion})`);
                  await new Promise(r => setTimeout(r, 300));
                } catch (err) {
                  console.log(`  ‚ùå Could not delete run ${run.id}: ${err.message}`);
                }
              }
            }
            console.log("\n‚úÖ Cleanup finished.");
