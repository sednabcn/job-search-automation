name: Job Search Orchestrator

on:
  schedule:
    # Run daily at 6 AM UTC
    - cron: '0 6 * * *'
  
  workflow_dispatch:
    inputs:
      pipeline_mode:
        description: 'Pipeline execution mode'
        required: true
        type: choice
        options:
          - full_pipeline      # Complete end-to-end pipeline
          - discovery_only     # Just discover jobs
          - scoring_only       # Score existing jobs
          - packages_only      # Generate packages from scored jobs
          - notifications_only # Send status emails
          - maintenance        # Cleanup old data
        default: 'full_pipeline'
      
      min_score_threshold:
        description: 'Minimum job score (0-100)'
        required: false
        type: number
        default: 70
      
      max_applications:
        description: 'Maximum applications to package'
        required: false
        type: number
        default: 20
      
      generate_cover_letters:
        description: 'Generate AI cover letters'
        required: false
        type: boolean
        default: false
      
      send_notifications:
        description: 'Send email notifications'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  DATA_DIR: 'job_search'
  MIN_SCORE: ${{ github.event.inputs.min_score_threshold || 70 }}
  MAX_APPLICATIONS: ${{ github.event.inputs.max_applications || 20 }}

jobs:
  # ========================================
  # STAGE 0: PIPELINE COORDINATOR
  # ========================================
  coordinator:
    name: Pipeline Coordinator
    runs-on: ubuntu-latest
    outputs:
      run_discovery: ${{ steps.plan.outputs.run_discovery }}
      run_scoring: ${{ steps.plan.outputs.run_scoring }}
      run_cover_letters: ${{ steps.plan.outputs.run_cover_letters }}
      run_packages: ${{ steps.plan.outputs.run_packages }}
      run_notifications: ${{ steps.plan.outputs.run_notifications }}
      run_maintenance: ${{ steps.plan.outputs.run_maintenance }}
      pipeline_id: ${{ steps.setup.outputs.pipeline_id }}
      timestamp: ${{ steps.setup.outputs.timestamp }}
    
    steps:
      - name: Setup Pipeline Context
        id: setup
        run: |
          PIPELINE_ID="pipeline-$(date +%Y%m%d-%H%M%S)"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "pipeline_id=$PIPELINE_ID" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          echo "üöÄ Job Search Pipeline Orchestrator"
          echo "Pipeline ID: $PIPELINE_ID"
          echo "Mode: ${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}"
          echo "Min Score: ${{ env.MIN_SCORE }}"
          echo "Max Applications: ${{ env.MAX_APPLICATIONS }}"
      
      - name: Determine Execution Plan
        id: plan
        run: |
          MODE="${{ github.event.inputs.pipeline_mode }}"
          
          # Default for scheduled runs
          if [ -z "$MODE" ]; then
            MODE="full_pipeline"
          fi
          
          case "$MODE" in
            full_pipeline)
              echo "run_discovery=true" >> $GITHUB_OUTPUT
              echo "run_scoring=true" >> $GITHUB_OUTPUT
              echo "run_cover_letters=${{ github.event.inputs.generate_cover_letters || 'false' }}" >> $GITHUB_OUTPUT
              echo "run_packages=true" >> $GITHUB_OUTPUT
              echo "run_notifications=${{ github.event.inputs.send_notifications || 'true' }}" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Full pipeline: Discovery ‚Üí Scoring ‚Üí Packages ‚Üí Notifications"
              ;;
            discovery_only)
              echo "run_discovery=true" >> $GITHUB_OUTPUT
              echo "run_scoring=false" >> $GITHUB_OUTPUT
              echo "run_cover_letters=false" >> $GITHUB_OUTPUT
              echo "run_packages=false" >> $GITHUB_OUTPUT
              echo "run_notifications=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Discovery only"
              ;;
            scoring_only)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_scoring=true" >> $GITHUB_OUTPUT
              echo "run_cover_letters=false" >> $GITHUB_OUTPUT
              echo "run_packages=false" >> $GITHUB_OUTPUT
              echo "run_notifications=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Scoring only"
              ;;
            packages_only)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_scoring=false" >> $GITHUB_OUTPUT
              echo "run_cover_letters=false" >> $GITHUB_OUTPUT
              echo "run_packages=true" >> $GITHUB_OUTPUT
              echo "run_notifications=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Package generation only"
              ;;
            notifications_only)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_scoring=false" >> $GITHUB_OUTPUT
              echo "run_cover_letters=false" >> $GITHUB_OUTPUT
              echo "run_packages=false" >> $GITHUB_OUTPUT
              echo "run_notifications=true" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Notifications only"
              ;;
            maintenance)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_scoring=false" >> $GITHUB_OUTPUT
              echo "run_cover_letters=false" >> $GITHUB_OUTPUT
              echo "run_packages=false" >> $GITHUB_OUTPUT
              echo "run_notifications=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=true" >> $GITHUB_OUTPUT
              echo "üìã Maintenance only"
              ;;
            *)
              echo "‚ùå Unknown mode: $MODE"
              exit 1
              ;;
          esac

  # ========================================
  # STAGE 1: JOB DISCOVERY
  # ========================================
  job-discovery:
    name: Discover Jobs
    runs-on: ubuntu-latest
    needs: coordinator
    if: needs.coordinator.outputs.run_discovery == 'true'
    
    outputs:
      jobs_discovered: ${{ steps.discover.outputs.job_count }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          pip install -q requests beautifulsoup4 selenium pandas
      
      - name: Run job discovery
        id: discover
        run: |
          echo "üîç Starting job discovery..."
          
          # Trigger discovery workflow and wait
          gh workflow run job-discovery-worker.yml
          
          echo "‚è≥ Waiting for discovery to complete..."
          sleep 60
          
          # Check results
          if [ -f "${{ env.DATA_DIR }}/discovered_jobs.json" ]; then
            JOB_COUNT=$(python3 -c "
          import json
          with open('${{ env.DATA_DIR }}/discovered_jobs.json') as f:
              data = json.load(f)
              print(len(data) if isinstance(data, list) else len(data.get('jobs', [])))
          ")
            echo "job_count=$JOB_COUNT" >> $GITHUB_OUTPUT
            echo "‚úÖ Discovered $JOB_COUNT jobs"
          else
            echo "job_count=0" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No jobs discovered"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ========================================
  # STAGE 2: CV MATCHING & JOB SCORING
  # ========================================
  cv-matching-and-scoring:
    name: CV Matching & Job Scoring
    runs-on: ubuntu-latest
    needs: [coordinator, job-discovery]
    if: |
      always() &&
      needs.coordinator.outputs.run_scoring == 'true' &&
      (needs.job-discovery.result == 'success' || needs.coordinator.outputs.run_discovery == 'false')
    
    outputs:
      high_score_count: ${{ steps.score.outputs.high_score_count }}
      top_score: ${{ steps.score.outputs.top_score }}
      scored_file: ${{ steps.score.outputs.scored_file }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          pip install -q pandas scikit-learn nltk pypdf2
      
      - name: Validate input files
        run: |
          echo "üîç Validating input files..."
          
          # Check for CV
          if [ ! -f "cv/my_cv.txt" ] && [ ! -f "cv/my_cv.pdf" ]; then
            echo "‚ö†Ô∏è No CV found, creating placeholder"
            mkdir -p cv
            echo "Software Engineer with experience in Python, JavaScript, React, AWS, Docker" > cv/my_cv.txt
          fi
          
          # Check for discovered jobs
          if [ ! -f "${{ env.DATA_DIR }}/discovered_jobs.json" ]; then
            echo "‚ùå No discovered jobs found"
            echo "skip_scoring=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ Input files validated"
      
      - name: Run CV matcher
        if: env.skip_scoring != 'true'
        run: |
          echo "üéØ Running CV matcher..."
          
          # Trigger CV matcher workflow
          gh workflow run cv_job_matcher.yml
          
          echo "‚è≥ Waiting for CV matching..."
          sleep 30
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create scoring preferences
        if: env.skip_scoring != 'true'
        run: |
          mkdir -p configs
          
          if [ ! -f "configs/scoring_preferences.json" ]; then
            cat > configs/scoring_preferences.json << 'PREFS'
          {
            "salary_min": 50000,
            "salary_max": 150000,
            "preferred_locations": ["remote", "london", "uk", "hybrid"],
            "experience_level": "mid-senior",
            "recency_days": 30,
            "weights": {
              "keywords": 40,
              "salary": 20,
              "location": 15,
              "company": 10,
              "experience": 10,
              "recency": 5
            },
            "must_have_keywords": [
              "python", "software engineer", "developer"
            ],
            "nice_to_have_keywords": [
              "react", "aws", "docker", "kubernetes", "ci/cd"
            ]
          }
          PREFS
            echo "‚úÖ Created default scoring preferences"
          fi
      
      - name: Score jobs
        if: env.skip_scoring != 'true'
        id: score
        run: |
          echo "üéØ Scoring jobs..."
          
          # Determine CV file
          CV_FILE="cv/my_cv.txt"
          if [ ! -f "$CV_FILE" ] && [ -f "cv/my_cv.pdf" ]; then
            CV_FILE="cv/my_cv.pdf"
          fi
          
          # Run scorer
          python3 .github/scripts/job_scorer.py \
            --cv "$CV_FILE" \
            --jobs "${{ env.DATA_DIR }}/discovered_jobs.json" \
            --output "${{ env.DATA_DIR }}/scored_jobs.json" \
            --preferences configs/scoring_preferences.json \
            --min-score ${{ env.MIN_SCORE }}
          
          # Extract statistics
          if [ -f "${{ env.DATA_DIR }}/scored_jobs.json" ]; then
            python3 << 'STATS'
          import json
          import sys
          
          try:
              with open('${{ env.DATA_DIR }}/scored_jobs.json') as f:
                  data = json.load(f)
              
              # Handle different formats
              if isinstance(data, dict):
                  jobs = data.get('jobs', data.get('filtered_jobs', []))
                  total = data.get('total_jobs', len(jobs))
                  filtered = data.get('filtered_jobs', len([j for j in jobs if j.get('total_score', 0) >= ${{ env.MIN_SCORE }}]))
                  top_score = max([j.get('total_score', 0) for j in jobs], default=0)
              else:
                  jobs = data
                  total = len(jobs)
                  filtered = len([j for j in jobs if j.get('total_score', 0) >= ${{ env.MIN_SCORE }}])
                  top_score = max([j.get('total_score', 0) for j in jobs], default=0)
              
              print(f"high_score_count={filtered}")
              print(f"top_score={top_score}")
              print(f"scored_file=${{ env.DATA_DIR }}/scored_jobs.json")
              
              with open('${{ github.output }}', 'a') as f:
                  f.write(f"high_score_count={filtered}\n")
                  f.write(f"top_score={top_score}\n")
                  f.write(f"scored_file=${{ env.DATA_DIR }}/scored_jobs.json\n")
              
              print(f"\n‚úÖ Scoring complete:")
              print(f"   Total jobs: {total}")
              print(f"   High-quality matches (‚â•{${{ env.MIN_SCORE }}}): {filtered}")
              print(f"   Top score: {top_score}")
              
          except Exception as e:
              print(f"‚ùå Error processing scored jobs: {e}", file=sys.stderr)
              sys.exit(1)
          STATS
          else
            echo "‚ùå Scored jobs file not created"
            exit 1
          fi
      
      - name: Commit scored results
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/scored_jobs.json
          git add configs/scoring_preferences.json
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "üéØ Scored ${{ steps.score.outputs.high_score_count }} high-quality job matches (score ‚â• ${{ env.MIN_SCORE }})"
          
          git push || echo "‚ö†Ô∏è Nothing to push"

  # ========================================
  # STAGE 3: AI COVER LETTER GENERATION
  # ========================================
  generate-cover-letters:
    name: Generate AI Cover Letters
    runs-on: ubuntu-latest
    needs: [coordinator, cv-matching-and-scoring]
    if: |
      needs.coordinator.outputs.run_cover_letters == 'true' &&
      needs.cv-matching-and-scoring.outputs.high_score_count > 0
    
    outputs:
      letters_generated: ${{ steps.generate.outputs.count }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          pip install -q openai
      
      - name: Generate cover letters
        id: generate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "‚ö†Ô∏è OPENAI_API_KEY not set, skipping cover letter generation"
            echo "count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üìù Generating AI cover letters..."
          
          python3 .github/scripts/cover_letter_generator.py \
            --jobs "${{ needs.cv-matching-and-scoring.outputs.scored_file }}" \
            --cv cv/my_cv.txt \
            --output-dir "${{ env.DATA_DIR }}/cover_letters" \
            --max-count ${{ env.MAX_APPLICATIONS }}
          
          COUNT=$(ls ${{ env.DATA_DIR }}/cover_letters/*.txt 2>/dev/null | wc -l || echo 0)
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Generated $COUNT cover letters"
      
      - name: Commit cover letters
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/cover_letters/
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "üìù Generated ${{ steps.generate.outputs.count }} AI cover letters"
          
          git push || echo "‚ö†Ô∏è Nothing to push"

  # ========================================
  # STAGE 4: APPLICATION PACKAGE GENERATION
  # ========================================
  generate-application-packages:
    name: Generate Application Packages
    runs-on: ubuntu-latest
    needs: [coordinator, cv-matching-and-scoring, generate-cover-letters]
    if: |
      always() &&
      needs.coordinator.outputs.run_packages == 'true' &&
      needs.cv-matching-and-scoring.result == 'success' &&
      needs.cv-matching-and-scoring.outputs.high_score_count > 0
    
    outputs:
      packages_created: ${{ steps.package.outputs.packages_created }}
      packages_failed: ${{ steps.package.outputs.packages_failed }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          pip install -q pypdf2 python-docx
      
      - name: Validate required files
        run: |
          echo "üîç Validating required files..."
          
          # Check for CV
          if [ ! -f "cv/my_cv.pdf" ]; then
            echo "‚ùå CV file not found at cv/my_cv.pdf"
            exit 1
          fi
          
          # Check for cover letter template
          if [ ! -f "cover_letter/my_cover.txt" ]; then
            echo "‚ö†Ô∏è Cover letter template not found, creating placeholder"
            mkdir -p cover_letter
            cat > cover_letter/my_cover.txt << 'COVER'
          Dear Hiring Manager,

          I am writing to express my interest in the [POSITION] position at [COMPANY].

          With my background in software development and proven track record of delivering high-quality solutions, I am confident I would be a valuable addition to your team.

          I look forward to discussing this opportunity further.

          Best regards,
          [YOUR NAME]
          COVER
          fi
          
          # Check for scored jobs
          if [ ! -f "${{ env.DATA_DIR }}/scored_jobs.json" ]; then
            echo "‚ùå No scored jobs found"
            echo "skip_packages=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ All required files present"
      
      - name: Create application packages
        if: env.skip_packages != 'true'
        id: package
        run: |
          python3 << 'EOF'
          import sys
          import json
          import hashlib
          from pathlib import Path
          from datetime import datetime
          
          sys.path.insert(0, '.github/scripts')
          
          print("="*70)
          print("üì¶ GENERATING APPLICATION PACKAGES")
          print("="*70)
          
          # Import required modules
          try:
              from application_prefiller import ApplicationPrefiller
              from application_tracker import ApplicationTracker
              print("‚úÖ Modules imported successfully")
          except ImportError as e:
              print(f"‚ùå Failed to import required modules: {e}")
              sys.exit(1)
          
          def generate_job_id(job):
              """Generate consistent job ID from job data"""
              if job.get('id'):
                  return str(job['id'])
              
              job_string = f"{job.get('company', '')}_{job.get('title', '')}_{job.get('location', '')}"
              job_hash = hashlib.md5(job_string.encode()).hexdigest()[:12]
              return f"job_{job_hash}"
          
          # Validate files
          cv_path = Path('cv/my_cv.pdf')
          cover_letter_path = Path('cover_letter/my_cover.txt')
          
          if not cv_path.exists():
              print(f"‚ùå CV not found at: {cv_path}")
              sys.exit(1)
          
          if not cover_letter_path.exists():
              print(f"‚ùå Cover letter not found at: {cover_letter_path}")
              sys.exit(1)
          
          # Load scored jobs
          scored_file = Path('${{ env.DATA_DIR }}/scored_jobs.json')
          with open(scored_file) as f:
              data = json.load(f)
          
          # Handle different formats
          if isinstance(data, dict):
              jobs = data.get('jobs', data.get('filtered_jobs', []))
          else:
              jobs = data
          
          # Filter to high-scoring jobs only
          high_score_jobs = [j for j in jobs if j.get('total_score', 0) >= ${{ env.MIN_SCORE }}]
          
          # Limit to max applications
          max_apps = min(len(high_score_jobs), ${{ env.MAX_APPLICATIONS }})
          selected_jobs = sorted(high_score_jobs, key=lambda x: x.get('total_score', 0), reverse=True)[:max_apps]
          
          print(f"\nüìä Processing {len(selected_jobs)} jobs (from {len(jobs)} total)")
          
          # Initialize
          prefiller = ApplicationPrefiller()
          tracker = ApplicationTracker('${{ env.DATA_DIR }}')
          
          packages_created = 0
          packages_failed = 0
          results = []
          
          for idx, job in enumerate(selected_jobs, 1):
              job_id = generate_job_id(job)
              company = job.get('company', 'Unknown Company')
              title = job.get('title', 'Unknown Position')
              score = job.get('total_score', 0)
              
              print(f"\n[{idx}/{len(selected_jobs)}] üì¶ {company} - {title} (Score: {score})")
              
              try:
                  # Determine platform
                  platform = job.get('source', 'generic').lower()
                  valid_platforms = ['linkedin', 'indeed', 'reed', 'glassdoor']
                  if platform not in valid_platforms:
                      platform = 'generic'
                  
                  # Check for custom cover letter
                  cover_letter_file = Path(f"${{ env.DATA_DIR }}/cover_letters/{job_id}.txt")
                  if cover_letter_file.exists():
                      cover_path = str(cover_letter_file)
                      print(f"   Using custom cover letter")
                  else:
                      cover_path = str(cover_letter_path)
                  
                  # Create package
                  package_dir = prefiller.create_application_package(
                      job_posting=job,
                      cv_path=str(cv_path),
                      cover_letter_path=cover_path,
                      platform=platform
                  )
                  
                  if not package_dir:
                      raise ValueError("Package creation returned None")
                  
                  print(f"   ‚úÖ Package: {package_dir}")
                  
                  # Add to tracker
                  tracker.add_application(
                      job_id=job_id,
                      job_data=job,
                      platform=platform,
                      package_path=str(package_dir)
                  )
                  
                  # Update status
                  tracker.update_status(
                      job_id=job_id,
                      status='package_created',
                      notes=f"Package ready. Score: {score}"
                  )
                  
                  packages_created += 1
                  results.append({
                      'job_id': job_id,
                      'company': company,
                      'title': title,
                      'score': score,
                      'status': 'success',
                      'package_path': str(package_dir)
                  })
                  
              except Exception as e:
                  packages_failed += 1
                  error_msg = str(e)
                  print(f"   ‚ùå Error: {error_msg}")
                  
                  results.append({
                      'job_id': job_id,
                      'company': company,
                      'title': title,
                      'score': score,
                      'status': 'failed',
                      'error': error_msg
                  })
                  
                  continue
          
          # Summary
          print("\n" + "="*70)
          print("üìä PACKAGE GENERATION SUMMARY")
          print("="*70)
          print(f"‚úÖ Successfully created: {packages_created}")
          print(f"‚ùå Failed: {packages_failed}")
          print(f"üì¶ Total processed: {len(selected_jobs)}")
          
          # Save tracker data
          tracker.save_applications()
          print("‚úÖ Application tracking saved")
          
          # Generate report
          report = tracker.generate_report()
          report_file = Path('${{ env.DATA_DIR }}/reports/tracker_report.md')
          report_file.parent.mkdir(parents=True, exist_ok=True)
          with open(report_file, 'w') as f:
              f.write(report)
          print(f"‚úÖ Report: {report_file}")
          
          # Save detailed results
          results_file = Path('${{ env.DATA_DIR }}/package_generation_results.json')
          with open(results_file, 'w') as f:
              json.dump({
                  'timestamp': datetime.now().isoformat(),
                  'total_jobs': len(selected_jobs),
                  'packages_created': packages_created,
                  'packages_failed': packages_failed,
                  'results': results
              }, f, indent=2)
          
          # Set outputs
          import os
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"packages_created={packages_created}\n")
              f.write(f"packages_failed={packages_failed}\n")
          
          print("="*70)
          
          # Exit with error if all failed
          if packages_created == 0 and len(selected_jobs) > 0:
              print("\n‚ùå All package generation attempts failed!")
              sys.exit(1)
          EOF
      
      - name: Commit packages and tracking data
        if: env.skip_packages != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check for changes
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Add generated files
          git add ${{ env.DATA_DIR }}/application_packages/
          git add ${{ env.DATA_DIR }}/applications.json
          git add ${{ env.DATA_DIR }}/analytics.json
          git add ${{ env.DATA_DIR }}/reports/
          git add ${{ env.DATA_DIR }}/package_generation_results.json
          
          TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')
          git commit -m "üì¶ Created ${{ steps.package.outputs.packages_created }} application packages - $TIMESTAMP" || {
            echo "Nothing to commit"
            exit 0
          }
          
          # Push with retry
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            if git push; then
              echo "‚úÖ Changes pushed"
              exit 0
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Push failed, retrying ($i/$MAX_RETRIES)..."
                sleep 2
                git pull --rebase
              else
                echo "‚ùå Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
      
      - name: Upload application packages
        if: env.skip_packages != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: application-packages-${{ github.run_number }}
          path: ${{ env.DATA_DIR }}/application_packages/
          retention-days: 90
          if-no-files-found: warn
      
      - name: Upload tracking data
        if: env.skip_packages != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: tracking-data-${{ github.run_number }}
          path: |
            ${{ env.DATA_DIR }}/applications.json
            ${{ env.DATA_DIR }}/analytics.json
            ${{ env.DATA_DIR }}/package_generation_results.json
            ${{ env.DATA_DIR }}/reports/
          retention-days: 90
          if-no-files-found: warn

  # ========================================
  # STAGE 5: STATUS & FOLLOW-UP MANAGEMENT
  # ========================================
  manage-status-and-followups:
    name: Manage Status & Follow-ups
    runs-on: ubuntu-latest
    needs: [coordinator, generate-application-packages]
    if: |
      always() &&
      (needs.generate-application-packages.result == 'success' || 
       needs.coordinator.outputs.run_notifications == 'true')
    
    outputs:
      status_updates: ${{ steps.status.outputs.updates_count }}
      due_reminders: ${{ steps.followup.outputs.due_count }}
      followups_needed: ${{ steps.followup.outputs.followup_count }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Auto-update application statuses
        id: status
        run: |
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.github/scripts')
          
          from application_tracker import ApplicationTracker
          from datetime import datetime, timedelta
          
          print("="*70)
          print("üìÑ AUTO-UPDATING APPLICATION STATUSES")
          print("="*70)
          
          tracker = ApplicationTracker('${{ env.DATA_DIR }}')
          updates_count = 0
          
          # Auto-transition: package_created -> ready_to_apply
          package_created_apps = tracker.get_applications_by_status('package_created')
          print(f"\nüì¶ Found {len(package_created_apps)} applications with packages")
          
          for app in package_created_apps:
              # Check if package was created recently (within last 2 hours)
              try:
                  last_updated = datetime.fromisoformat(app.get('last_updated', app.get('created_at')))
                  if datetime.now() - last_updated < timedelta(hours=2):
                      success = tracker.update_status(
                          app['id'],
                          'ready_to_apply',
                          'Package ready for submission',
                          auto_reminders=True
                      )
                      if success:
                          updates_count += 1
                          print(f"   ‚úÖ {app['company']} -> ready_to_apply")
              except Exception as e:
                  print(f"   ‚ö†Ô∏è {app['company']}: {e}")
          
          print(f"\nüìä Status updates: {updates_count}")
          
          # Save changes
          tracker.save_applications()
          
          # Set output
          import os
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"updates_count={updates_count}\n")
          
          print("="*70)
          EOF
      
      - name: Check follow-ups and reminders
        id: followup
        run: |
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.github/scripts')
          
          from application_tracker import ApplicationTracker
          from datetime import datetime, timedelta
          import json
          
          print("="*70)
          print("üì¨ CHECKING FOLLOW-UPS & REMINDERS")
          print("="*70)
          
          tracker = ApplicationTracker('${{ env.DATA_DIR }}')
          
          # Get applications needing follow-up (submitted > 7 days ago)
          all_apps = tracker.applications
          followups_needed = []
          due_reminders = []
          
          for app in all_apps:
              status = app.get('status', '')
              
              # Check for follow-ups needed
              if status in ['submitted', 'interviewed']:
                  try:
                      last_updated = datetime.fromisoformat(app.get('last_updated', app.get('created_at')))
                      days_since = (datetime.now() - last_updated).days
                      
                      if days_since >= 7 and status == 'submitted':
                          followups_needed.append({
                              'job_id': app['id'],
                              'company': app['company'],
                              'position': app['position'],
                              'days_since_submission': days_since,
                              'action': 'Send follow-up email',
                              'priority': 'high' if days_since >= 14 else 'medium'
                          })
                      elif days_since >= 3 and status == 'interviewed':
                          followups_needed.append({
                              'job_id': app['id'],
                              'company': app['company'],
                              'position': app['position'],
                              'days_since_interview': days_since,
                              'action': 'Send thank you / follow-up',
                              'priority': 'high'
                          })
                  except:
                      pass
              
              # Check for due reminders
              if app.get('reminders'):
                  for reminder in app['reminders']:
                      try:
                          due_date = datetime.fromisoformat(reminder['due_date'])
                          if due_date <= datetime.now() and not reminder.get('completed', False):
                              due_reminders.append({
                                  'job_id': app['id'],
                                  'company': app['company'],
                                  'position': app['position'],
                                  'reminder': reminder
                              })
                      except:
                          pass
          
          print(f"\nüìä Follow-ups needed: {len(followups_needed)}")
          print(f"‚è∞ Due reminders: {len(due_reminders)}")
          
          if followups_needed:
              print("\nüìã Follow-up List:")
              for fu in followups_needed[:5]:  # Show first 5
                  print(f"  ‚Ä¢ {fu['company']} - {fu['position']} ({fu['action']})")
          
          if due_reminders:
              print("\n‚è∞ Due Reminders:")
              for r in due_reminders[:5]:  # Show first 5
                  print(f"  ‚Ä¢ {r['company']} - {r['reminder']['message']}")
          
          # Save follow-up data
          followup_data = {
              'generated_at': datetime.now().isoformat(),
              'follow_ups': followups_needed,
              'due_reminders': due_reminders,
              'summary': {
                  'follow_ups_count': len(followups_needed),
                  'due_reminders_count': len(due_reminders)
              }
          }
          
          with open('${{ env.DATA_DIR }}/followup_summary.json', 'w') as f:
              json.dump(followup_data, f, indent=2)
          
          # Generate text report
          report_lines = []
          report_lines.append("# Follow-up & Reminder Report")
          report_lines.append(f"\nGenerated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
          report_lines.append(f"\n## Summary")
          report_lines.append(f"- Follow-ups needed: {len(followups_needed)}")
          report_lines.append(f"- Due reminders: {len(due_reminders)}")
          
          if followups_needed:
              report_lines.append(f"\n## Applications Needing Follow-up ({len(followups_needed)})")
              for fu in followups_needed:
                  report_lines.append(f"\n### {fu['company']} - {fu['position']}")
                  report_lines.append(f"- **Action:** {fu['action']}")
                  report_lines.append(f"- **Priority:** {fu['priority']}")
                  if 'days_since_submission' in fu:
                      report_lines.append(f"- **Days since submission:** {fu['days_since_submission']}")
          
          if due_reminders:
              report_lines.append(f"\n## Due Reminders ({len(due_reminders)})")
              for r in due_reminders:
                  report_lines.append(f"\n### {r['company']} - {r['position']}")
                  report_lines.append(f"- **Reminder:** {r['reminder']['message']}")
                  report_lines.append(f"- **Due date:** {r['reminder']['due_date']}")
          
          report_file = '${{ env.DATA_DIR }}/reports/followup_report.md'
          with open(report_file, 'w') as f:
              f.write('\n'.join(report_lines))
          
          print(f"\n‚úÖ Report saved: {report_file}")
          
          # Set outputs
          import os
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"due_count={len(due_reminders)}\n")
              f.write(f"followup_count={len(followups_needed)}\n")
          
          print("="*70)
          EOF
      
      - name: Commit status updates and follow-up data
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/applications.json
          git add ${{ env.DATA_DIR }}/analytics.json
          git add ${{ env.DATA_DIR }}/followup_summary.json
          git add ${{ env.DATA_DIR }}/reports/followup_report.md
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "üìÑ Status updates: ${{ steps.status.outputs.updates_count }} | Follow-ups: ${{ steps.followup.outputs.followup_count }}"
          
          git push || echo "‚ö†Ô∏è Nothing to push"
      
      - name: Upload follow-up data
        uses: actions/upload-artifact@v4
        with:
          name: followup-data-${{ github.run_number }}
          path: |
            ${{ env.DATA_DIR }}/followup_summary.json
            ${{ env.DATA_DIR }}/reports/followup_report.md
          retention-days: 30

  # ========================================
  # STAGE 6: EMAIL NOTIFICATIONS
  # ========================================
  send-notifications:
    name: Send Email Notifications
    runs-on: ubuntu-latest
    needs: [coordinator, cv-matching-and-scoring, generate-application-packages, manage-status-and-followups]
    if: |
      always() &&
      needs.coordinator.outputs.run_notifications == 'true' &&
      (needs.cv-matching-and-scoring.result == 'success' || 
       needs.generate-application-packages.result == 'success')
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Download follow-up data
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: followup-data-${{ github.run_number }}
          path: ${{ env.DATA_DIR }}
      
      - name: Send comprehensive email notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.SMTP_USER }}
          password: ${{ secrets.SMTP_PASS }}
          subject: "üöÄ Job Search Pipeline Complete | üéØ ${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }} Matches | ‚è∞ ${{ needs.manage-status-and-followups.outputs.due_reminders || 0 }} Reminders"
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: Job Search Automation <${{ secrets.SMTP_USER }}>
          html_body: |
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { 
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                  line-height: 1.6; 
                  color: #333; 
                  background: #f5f5f5;
                  margin: 0;
                  padding: 0;
                }
                .container { 
                  max-width: 700px; 
                  margin: 20px auto; 
                  background: white;
                  border-radius: 12px;
                  overflow: hidden;
                  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                }
                .header { 
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                  color: white; 
                  padding: 40px 30px; 
                  text-align: center;
                }
                .header h1 { margin: 0 0 10px 0; font-size: 28px; }
                .header p { margin: 0; opacity: 0.9; font-size: 14px; }
                .stats-grid { 
                  display: grid; 
                  grid-template-columns: repeat(2, 1fr); 
                  gap: 20px; 
                  padding: 30px;
                  background: #f8f9fa;
                }
                .stat-card { 
                  background: white; 
                  padding: 20px; 
                  border-radius: 10px; 
                  text-align: center;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                }
                .stat-number { 
                  font-size: 36px; 
                  font-weight: bold; 
                  color: #667eea;
                  margin: 0;
                }
                .stat-label { 
                  color: #666; 
                  font-size: 13px;
                  margin-top: 5px;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                }
                .section { 
                  padding: 25px 30px; 
                  border-bottom: 1px solid #eee;
                }
                .section:last-child { border-bottom: none; }
                .section h2 { 
                  margin: 0 0 15px 0;
                  font-size: 20px;
                  color: #333;
                }
                .alert { 
                  padding: 15px 20px; 
                  margin: 15px 0; 
                  border-radius: 8px;
                  border-left: 4px solid;
                }
                .alert-warning { 
                  background: #fff3cd; 
                  border-color: #ffc107;
                  color: #856404;
                }
                .alert-danger { 
                  background: #f8d7da; 
                  border-color: #dc3545;
                  color: #721c24;
                }
                .alert-success { 
                  background: #d4edda; 
                  border-color: #28a745;
                  color: #155724;
                }
                .alert-info {
                  background: #d1ecf1;
                  border-color: #17a2b8;
                  color: #0c5460;
                }
                .btn { 
                  display: inline-block; 
                  padding: 12px 28px; 
                  background: #667eea; 
                  color: white !important; 
                  text-decoration: none; 
                  border-radius: 6px; 
                  margin: 10px 5px;
                  font-weight: 500;
                  transition: background 0.3s;
                }
                .btn:hover { background: #5568d3; }
                .footer { 
                  background: #f8f9fa;
                  padding: 25px 30px; 
                  font-size: 13px; 
                  color: #666; 
                  text-align: center;
                  border-top: 1px solid #eee;
                }
                .footer a { color: #667eea; text-decoration: none; }
                ul { padding-left: 20px; }
                li { margin: 8px 0; }
                strong { color: #333; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>üöÄ Job Search Pipeline Complete</h1>
                  <p>Execution completed on ${{ needs.coordinator.outputs.timestamp }}</p>
                  <p>Pipeline ID: ${{ needs.coordinator.outputs.pipeline_id }}</p>
                </div>

                <div class="stats-grid">
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }}</div>
                    <div class="stat-label">High-Quality Matches</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.generate-application-packages.outputs.packages_created || 0 }}</div>
                    <div class="stat-label">Packages Created</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.manage-status-and-followups.outputs.due_reminders || 0 }}</div>
                    <div class="stat-label">Due Reminders</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.manage-status-and-followups.outputs.followups_needed || 0 }}</div>
                    <div class="stat-label">Follow-ups Needed</div>
                  </div>
                </div>

                <div class="section">
                  <h2>üéØ Job Matches</h2>
                  <p>Found <strong>${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }}</strong> high-quality job matches (score ‚â• ${{ env.MIN_SCORE }})</p>
                  <p>Top match score: <strong>${{ needs.cv-matching-and-scoring.outputs.top_score || 'N/A' }}</strong></p>
                  
                  <div class="alert alert-success">
                    <strong>‚úÖ Success!</strong> Jobs have been scored and ranked by relevance.
                  </div>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/scored_jobs.json" class="btn">
                    View Scored Jobs
                  </a>
                </div>

                <div class="section">
                  <h2>üì¶ Application Packages</h2>
                  <p><strong>${{ needs.generate-application-packages.outputs.packages_created || 0 }}</strong> ready-to-submit application packages created</p>
                  
                  <p><strong>Next Steps:</strong></p>
                  <ul>
                    <li>Review application packages in the repository</li>
                    <li>Customize cover letters if needed</li>
                    <li>Submit applications through respective platforms</li>
                    <li>Update application status after submission</li>
                  </ul>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }}/application_packages" class="btn">
                    View Packages
                  </a>
                </div>

                <div class="section">
                  <h2>‚è∞ Action Required: Reminders</h2>
                  <p><strong>${{ needs.manage-status-and-followups.outputs.due_reminders || 0 }}</strong> reminders are due</p>
                  
                  <div class="alert alert-info">
                    <strong>‚ÑπÔ∏è Status:</strong> Check the follow-up report for detailed reminder information.
                  </div>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/reports/followup_report.md" class="btn">
                    View Reminder Report
                  </a>
                </div>

                <div class="section">
                  <h2>üìû Follow-up Actions</h2>
                  <p><strong>${{ needs.manage-status-and-followups.outputs.followups_needed || 0 }}</strong> applications need follow-up</p>
                  
                  <div class="alert alert-warning">
                    <strong>üí° Reminder:</strong> Applications submitted more than 7 days ago should be followed up.
                  </div>
                  
                  <p><strong>Follow-up Guidelines:</strong></p>
                  <ul>
                    <li><strong>Day 7:</strong> Send polite follow-up email</li>
                    <li><strong>Day 14:</strong> Second follow-up or phone call</li>
                    <li><strong>Day 21:</strong> Final follow-up, consider moving on</li>
                  </ul>
                </div>

                <div class="section">
                  <h2>üìä Pipeline Summary</h2>
                  <p><strong>Execution Mode:</strong> ${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}</p>
                  <p><strong>Status Updates:</strong> ${{ needs.manage-status-and-followups.outputs.status_updates || 0 }} applications updated</p>
                  
                  <p><strong>Stage Results:</strong></p>
                  <ul>
                    <li>‚úÖ Job Discovery: Complete</li>
                    <li>‚úÖ CV Matching & Scoring: ${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }} matches</li>
                    <li>‚úÖ Package Generation: ${{ needs.generate-application-packages.outputs.packages_created || 0 }} packages</li>
                    <li>‚úÖ Status Management: ${{ needs.manage-status-and-followups.outputs.status_updates || 0 }} updates</li>
                  </ul>
                </div>

                <div class="footer">
                  <p><strong>üìÑ Attachments:</strong> Follow-up summary and detailed report included</p>
                  <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Workflow Run</a> | 
                     <a href="${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }}">View Data Directory</a></p>
                  <p style="margin-top: 15px; color: #999;">Automated by Job Search Orchestrator</p>
                </div>
              </div>
            </body>
            </html>
          attachments: |
            ${{ env.DATA_DIR }}/followup_summary.json
            ${{ env.DATA_DIR }}/reports/followup_report.md

  # ========================================
  # STAGE 7: MAINTENANCE
  # ========================================
  maintenance:
    name: System Maintenance
    runs-on: ubuntu-latest
    needs: coordinator
    if: needs.coordinator.outputs.run_maintenance == 'true'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Clean old data
        run: |
          python3 << 'EOF'
          from pathlib import Path
          from datetime import datetime, timedelta
          import json
          import shutil
          
          print("="*70)
          print("üßπ SYSTEM MAINTENANCE")
          print("="*70)
          
          data_dir = Path('${{ env.DATA_DIR }}')
          
          # Archive old packages (>90 days)
          packages_dir = data_dir / 'application_packages'
          if packages_dir.exists():
              archive_dir = data_dir / 'archived_packages'
              archive_dir.mkdir(exist_ok=True)
              
              cutoff_date = datetime.now() - timedelta(days=90)
              archived_count = 0
              
              for package in packages_dir.iterdir():
                  if package.is_dir():
                      mtime = datetime.fromtimestamp(package.stat().st_mtime)
                      if mtime < cutoff_date:
                          shutil.move(str(package), str(archive_dir / package.name))
                          archived_count += 1
              
              print(f"üì¶ Archived {archived_count} old packages")
          
          # Clean up old scored job files
          for old_file in data_dir.glob('scored_jobs_*.json'):
              mtime = datetime.fromtimestamp(old_file.stat().st_mtime)
              if datetime.now() - mtime > timedelta(days=30):
                  old_file.unlink()
                  print(f"üóëÔ∏è  Deleted old file: {old_file.name}")
          
          # Compact analytics data
          analytics_file = data_dir / 'analytics.json'
          if analytics_file.exists():
              with open(analytics_file) as f:
                  analytics = json.load(f)
              
              # Keep only last 90 days of daily stats
              if 'daily_stats' in analytics:
                  cutoff = (datetime.now() - timedelta(days=90)).isoformat()
                  analytics['daily_stats'] = {
                      k: v for k, v in analytics['daily_stats'].items() 
                      if k >= cutoff
                  }
              
              with open(analytics_file, 'w') as f:
                  json.dump(analytics, f, indent=2)
              
              print("üìä Compacted analytics data")
          
          print("‚úÖ Maintenance complete")
          print("="*70)
          EOF
      
      - name: Trigger workflow cleanup
        run: |
          echo "üßπ Triggering workflow cleanup..."
          gh workflow run cleanup-old-workflows.yml || echo "‚ö†Ô∏è Cleanup workflow not found"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Commit maintenance changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "üßπ System maintenance - $(date +'%Y-%m-%d')"
          
          git push || echo "‚ö†Ô∏è Nothing to push"

  # ========================================
  # STAGE 8: PIPELINE SUMMARY & REPORTING
  # ========================================
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [
      coordinator,
      job-discovery,
      cv-matching-and-scoring,
      generate-cover-letters,
      generate-application-packages,
      manage-status-and-followups,
      send-notifications,
      maintenance
    ]
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Generate summary report
        run: |
          cat << 'SUMMARY' >> $GITHUB_STEP_SUMMARY
          # üöÄ Job Search Pipeline Summary
          
          **Pipeline ID:** ${{ needs.coordinator.outputs.pipeline_id }}  
          **Timestamp:** ${{ needs.coordinator.outputs.timestamp }}  
          **Mode:** ${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}
          
          ## üìä Execution Results
          
          | Stage | Status | Details |
          |-------|--------|---------|
          | Discovery | ${{ needs.job-discovery.result || '‚è≠Ô∏è skipped' }} | ${{ needs.job-discovery.outputs.jobs_discovered || 0 }} jobs discovered |
          | CV Matching & Scoring | ${{ needs.cv-matching-and-scoring.result || '‚è≠Ô∏è skipped' }} | ${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }} high-quality matches (score ‚â• ${{ env.MIN_SCORE }}) |
          | Cover Letters | ${{ needs.generate-cover-letters.result || '‚è≠Ô∏è skipped' }} | ${{ needs.generate-cover-letters.outputs.letters_generated || 0 }} AI letters generated |
          | Package Generation | ${{ needs.generate-application-packages.result || '‚è≠Ô∏è skipped' }} | ${{ needs.generate-application-packages.outputs.packages_created || 0 }} packages created |
          | Status Management | ${{ needs.manage-status-and-followups.result || '‚è≠Ô∏è skipped' }} | ${{ needs.manage-status-and-followups.outputs.status_updates || 0 }} status updates |
          | Notifications | ${{ needs.send-notifications.result || '‚è≠Ô∏è skipped' }} | Email sent |
          | Maintenance | ${{ needs.maintenance.result || '‚è≠Ô∏è skipped' }} | System cleaned |
          
          ## üéØ Key Metrics
          
          - **High-Quality Matches:** ${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }}
          - **Top Match Score:** ${{ needs.cv-matching-and-scoring.outputs.top_score || 'N/A' }}
          - **Packages Created:** ${{ needs.generate-application-packages.outputs.packages_created || 0 }}
          - **Due Reminders:** ${{ needs.manage-status-and-followups.outputs.due_reminders || 0 }}
          - **Follow-ups Needed:** ${{ needs.manage-status-and-followups.outputs.followups_needed || 0 }}
          
          ## üìÅ Data Files
          
          - [Scored Jobs](${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/scored_jobs.json)
          - [Application Packages](${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }}/application_packages)
          - [Follow-up Report](${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/reports/followup_report.md)
          - [Tracking Data](${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/applications.json)
          
          ## üîó Quick Links
          
          - [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Download Artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts)
          - [Data Directory](${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }})
          
          ---
          
          *Pipeline executed successfully. Check email for detailed notification.*
          SUMMARY
      
      - name: Create summary issue
        if: |
          github.event_name == 'schedule' ||
          github.event.inputs.pipeline_mode == 'full_pipeline'
        uses: actions/github-script@v7
        with:
          script: |
            const statusEmoji = {
              'success': '‚úÖ',
              'failure': '‚ùå',
              'skipped': '‚è≠Ô∏è',
              'cancelled': 'üö´'
            };
            
            const pipelineId = '${{ needs.coordinator.outputs.pipeline_id }}';
            const timestamp = '${{ needs.coordinator.outputs.timestamp }}';
            const mode = '${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}';
            
            const discoveryResult = '${{ needs.job-discovery.result || 'skipped' }}';
            const scoringResult = '${{ needs.cv-matching-and-scoring.result || 'skipped' }}';
            const packagesResult = '${{ needs.generate-application-packages.result || 'skipped' }}';
            const notificationsResult = '${{ needs.send-notifications.result || 'skipped' }}';
            
            const body = `# üöÄ Job Search Pipeline Summary
            
            **Pipeline ID:** ${pipelineId}  
            **Timestamp:** ${timestamp}  
            **Mode:** ${mode}
            
            ## Stage Results
            
            | Stage | Status |
            |-------|--------|
            | Job Discovery | ${statusEmoji[discoveryResult]} ${discoveryResult} |
            | CV Matching & Scoring | ${statusEmoji[scoringResult]} ${scoringResult} |
            | Package Generation | ${statusEmoji[packagesResult]} ${packagesResult} |
            | Notifications | ${statusEmoji[notificationsResult]} ${notificationsResult} |
            
            ## Key Metrics
            
            - **High-Quality Matches:** ${{ needs.cv-matching-and-scoring.outputs.high_score_count || 0 }}
            - **Packages Created:** ${{ needs.generate-application-packages.outputs.packages_created || 0 }}
            - **Due Reminders:** ${{ needs.manage-status-and-followups.outputs.due_reminders || 0 }}
            - **Follow-ups Needed:** ${{ needs.manage-status-and-followups.outputs.followups_needed || 0 }}
            
            ## Quick Links
            
            - [Scored Jobs](${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/scored_jobs.json)
            - [Application Packages](${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }}/application_packages)
            - [Follow-up Report](${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/reports/followup_report.md)
            
            ---
            
            [View This Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üìä Pipeline Summary - ${pipelineId}`,
              body: body,
              labels: ['job-search', 'pipeline-summary', 'automated']
            });
