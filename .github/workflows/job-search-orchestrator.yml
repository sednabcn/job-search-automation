name: Job Search Orchestrator

on:
  schedule:
    # Run daily at 6 AM UTC
    - cron: '0 6 * * *'
  
  workflow_dispatch:
    inputs:
      pipeline_mode:
        description: 'Pipeline execution mode'
        required: true
        type: choice
        options:
          - full_pipeline      # Discovery ‚Üí Match ‚Üí Email
          - discovery_only     # Just discover jobs
          - match_only         # Just match existing jobs
          - manual_entry       # Open form submission
          - maintenance        # Cleanup old data
        default: 'full_pipeline'
      
      discovery_mode:
        description: 'Discovery mode (if supported by job-discovery-worker.yml)'
        required: false
        type: choice
        options:
          - full
          - incremental
          - test
        default: 'full'
      
      data_directory:
        description: 'Data directory path'
        required: false
        type: string
        default: 'job_search'

      cv_file:
        description: 'CV file path (supports .pdf, .docx, .txt)'
        required: false
        type: string
        default: 'cv/my_cv.pdf'
    
      cover_letter_file:
        description: 'Cover letter file path (supports .pdf, .docx, .txt)'
        required: false
        type: string
        default: 'cover_letter/my_cover.txt'
      
      enable_scoring:
        description: 'Enable job scoring'
        required: false
        type: boolean
        default: true
      
      min_score_threshold:
        description: 'Minimum job score (0-100)'
        required: false
        type: number
        default: 70
      
      generate_cover_letters:
        description: 'Generate AI cover letters'
        required: false
        type: boolean
        default: false
      
      max_cover_letters:
        description: 'Max cover letters to generate'
        required: false
        type: number
        default: 10
  
      send_emails:
        description: 'Send email notifications'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  DATA_DIR: ${{ github.event.inputs.data_directory || 'job_search' }}
  CV_FILE: ${{ github.event.inputs.cv_file || 'cv/my_cv.pdf' }}
  COVER_LETTER_FILE: ${{ github.event.inputs.cover_letter_file || 'cover_letter/my_cover.txt' }} 
  ENABLE_SCORING: ${{ github.event.inputs.enable_scoring || 'true' }}
  MIN_SCORE: ${{ github.event.inputs.min_score_threshold || 70 }}
  ENABLE_AI: ${{ github.event.inputs.generate_cover_letters || 'false' }}
  MAX_AI_LETTERS: ${{ github.event.inputs.max_cover_letters || 10 }}


jobs:
  # ========================================
  # STAGE 0: PIPELINE COORDINATOR
  # ========================================
  coordinator:
    name: Pipeline Coordinator
    runs-on: ubuntu-latest
    outputs:
      run_discovery: ${{ steps.plan.outputs.run_discovery }}
      run_matching: ${{ steps.plan.outputs.run_matching }}
      run_emails: ${{ steps.plan.outputs.run_emails }}
      run_maintenance: ${{ steps.plan.outputs.run_maintenance }}
      pipeline_id: ${{ steps.setup.outputs.pipeline_id }}
      timestamp: ${{ steps.setup.outputs.timestamp }}
    
    steps:
      - name: Setup Pipeline Context
        id: setup
        run: |
          PIPELINE_ID="pipeline-$(date +%Y%m%d-%H%M%S)"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "pipeline_id=$PIPELINE_ID" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          echo "üöÄ Job Search Pipeline Orchestrator"
          echo "Pipeline ID: $PIPELINE_ID"
          echo "Mode: ${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}"
      
      - name: Determine Execution Plan
        id: plan
        run: |
          MODE="${{ github.event.inputs.pipeline_mode }}"
          
          # Default for scheduled runs
          if [ -z "$MODE" ]; then
            MODE="full_pipeline"
          fi
          
          case "$MODE" in
            full_pipeline)
              echo "run_discovery=true" >> $GITHUB_OUTPUT
              echo "run_matching=true" >> $GITHUB_OUTPUT
              echo "run_emails=true" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Plan: Full pipeline (Discover ‚Üí Match ‚Üí Email)"
              ;;
            discovery_only)
              echo "run_discovery=true" >> $GITHUB_OUTPUT
              echo "run_matching=false" >> $GITHUB_OUTPUT
              echo "run_emails=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Plan: Discovery only"
              ;;
            match_only)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_matching=true" >> $GITHUB_OUTPUT
              echo "run_emails=true" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Plan: Matching only"
              ;;
            manual_entry)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_matching=false" >> $GITHUB_OUTPUT
              echo "run_emails=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=false" >> $GITHUB_OUTPUT
              echo "üìã Plan: Manual entry (use form_submit_workflow.yml)"
              ;;
            maintenance)
              echo "run_discovery=false" >> $GITHUB_OUTPUT
              echo "run_matching=false" >> $GITHUB_OUTPUT
              echo "run_emails=false" >> $GITHUB_OUTPUT
              echo "run_maintenance=true" >> $GITHUB_OUTPUT
              echo "üìã Plan: Maintenance only"
              ;;
            *)
              echo "‚ùå Unknown mode: $MODE"
              exit 1
              ;;
          esac

  # ========================================
  # STAGE 1: JOB DISCOVERY
  # ========================================
  trigger-discovery:
    name: Trigger Job Discovery
    runs-on: ubuntu-latest
    needs: coordinator
    if: needs.coordinator.outputs.run_discovery == 'true'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Trigger Job Discovery Workflow
        run: |
          echo "üîç Triggering job discovery workflow..."
          
          # Trigger without any inputs - let the workflow use its defaults
          # If job-discovery-worker.yml requires specific inputs, uncomment and adjust:
          # MODE="${{ github.event.inputs.discovery_mode || 'full' }}"
          # gh workflow run job-discovery-worker.yml -f mode="$MODE"
          
          gh workflow run job-discovery-worker.yml
          
          echo "‚úÖ Discovery workflow triggered"
          echo "‚ÑπÔ∏è  Using job-discovery-worker.yml default configuration"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Wait for Discovery Completion
        run: |
          echo "‚è≥ Waiting for discovery workflow to complete..."
          sleep 30
          
          # Check last workflow run status
          echo "üìä Recent discovery workflow runs:"
          gh run list --workflow=job-discovery-worker.yml --limit=3 --json status,conclusion,createdAt,displayTitle \
            --jq '.[] | "\(.createdAt) - \(.displayTitle) - \(.status) - \(.conclusion // "pending")"'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ========================================
  # STAGE 2: KEYWORD EXTRACTION & CONFIG UPDATE
  # ========================================
  trigger-keyword-extraction:
    name: Trigger Keyword Extraction
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-discovery]
    if: |
      needs.coordinator.outputs.run_discovery == 'true' &&
      needs.trigger-discovery.result == 'success'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Trigger Keyword Extraction
        run: |
          echo "üîë Triggering keyword extraction and config update..."
          
          # Trigger without inputs if they're not supported
          # Uncomment and adjust if specific inputs are needed:
          # gh workflow run job-manager-center-multiplatform.yml \
          #   -f update_config=true \
          #   -f trigger_discovery=false
          
          gh workflow run job-manager-center-multiplatform.yml
          
          echo "‚úÖ Keyword extraction workflow triggered"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Wait for Config Update
        run: |
          echo "‚è≥ Waiting for config update..."
          sleep 20

  # ========================================
  # STAGE 3: CV MATCHING
  # ========================================
  trigger-matching:
    name: Trigger CV Matching
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-discovery]
    if: |
      always() &&
      needs.coordinator.outputs.run_matching == 'true' &&
      (needs.trigger-discovery.result == 'success' || needs.coordinator.outputs.run_discovery == 'false')
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Trigger CV Matcher
        run: |
          echo "üéØ Triggering CV matching..."
          
          # Trigger without inputs - let cv_job_matcher.yml use its defaults
          # If specific inputs are supported, uncomment and adjust:
          # gh workflow run cv_job_matcher.yml -f threshold="75"
          
          gh workflow run cv_job_matcher.yml
          
          echo "‚úÖ CV matching workflow triggered"
          echo "‚ÑπÔ∏è  Using cv_job_matcher.yml default configuration"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Wait for Matching Completion
        run: |
          echo "‚è≥ Waiting for matching to complete..."
          sleep 30
          
          echo "üìä Recent CV matcher workflow runs:"
          gh run list --workflow=cv_job_matcher.yml --limit=3 --json status,conclusion,createdAt \
            --jq '.[] | "\(.createdAt) - \(.status) - \(.conclusion // "pending")"'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# ========================================
  # NEW: JOB SCORING STAGE
  # ========================================
  job-scoring:
    name: Score Jobs by Relevance
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-discovery]
    if: |
      always() &&
      (needs.trigger-discovery.result == 'success' || needs.coordinator.outputs.run_discovery == 'false')
    
    outputs:
      high_score_count: ${{ steps.score.outputs.high_score_count }}
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install scoring dependencies
        run: |
           pip install pandas scikit-learn nltk PyPDF2 python-docx
    
           # Download NLTK data
           python3 << 'EOF'
           import nltk
           try:
             nltk.download('stopwords', quiet=True)
             nltk.download('punkt', quiet=True)
             print("‚úÖ NLTK data downloaded")
           except Exception as e:
             print(f"‚ö†Ô∏è  NLTK download failed: {e}")
           EOF

      - name: Convert CV to text if needed
        run: |
          CV_PATH="${{ env.CV_FILE }}"
          CV_EXT="${CV_PATH##*.}"
    
          if [ "$CV_EXT" = "pdf" ] || [ "$CV_EXT" = "PDF" ]; then
             echo "üìÑ Converting PDF to text..."
      
             # Install pdftotext
             sudo apt-get update
             sudo apt-get install -y poppler-utils
      
             # Convert PDF to text
             CV_TXT="${CV_PATH%.pdf}.txt"
             pdftotext "$CV_PATH" "$CV_TXT"
      
             if [ -f "$CV_TXT" ]; then
                echo "‚úÖ Converted to: $CV_TXT"
                echo "CV_FILE=$CV_TXT" >> $GITHUB_ENV
             else
                echo "‚ùå Conversion failed"
                exit 1
             fi
          else
             echo "‚ÑπÔ∏è  CV is already in text format: $CV_PATH"
          fi

      - name: Test CV reading
        run: |
          python3 << 'EOF'
          from pathlib import Path
    
          cv_path = Path('${{ env.CV_FILE }}')
          print(f"CV Path: {cv_path}")
          print(f"Exists: {cv_path.exists()}")
          print(f"Size: {cv_path.stat().st_size if cv_path.exists() else 'N/A'}")
          print(f"Extension: {cv_path.suffix}")
    
          # Try to determine if it's readable
          if cv_path.suffix == '.txt':
                   print("‚úÖ Text file - should work")
          elif cv_path.suffix == '.pdf':
                   print("‚ö†Ô∏è  PDF file - needs PyPDF2")
                   try:
                     import PyPDF2
                     print("‚úÖ PyPDF2 is installed")
                   except ImportError:
                     print("‚ùå PyPDF2 not installed - install with: pip install PyPDF2")
          EOF

          
      - name: Run job scorer
        id: score
        run: |
          # Check if required files exist
          CV_PATH="${{ env.CV_FILE }}"
    
          # Check if CV exists
          if [ ! -f "$CV_PATH" ]; then
              echo "‚ö†Ô∏è CV file not found at: $CV_PATH, trying alternatives..."
      
              # Try common CV locations
              for alt_cv in cv/my_cv.pdf cv/resume.pdf cv/cv.pdf cv/*.pdf; do
                 if [ -f "$alt_cv" ]; then
                     echo "‚úÖ Found alternative CV: $alt_cv"
                     CV_PATH="$alt_cv"
                     break
                  fi
              done
      
              if [ ! -f "$CV_PATH" ]; then
                 echo "‚ùå No CV found, creating placeholder"
                 mkdir -p cv
                 echo "Software Engineer with experience in Python, JavaScript, React, Node.js, AWS, Docker, Kubernetes, SQL, MongoDB, Git, CI/CD" > cv/my_cv.txt
                 CV_PATH="cv/my_cv.txt"
              fi
          fi
    
          echo "üìÑ Using CV: $CV_PATH"
          
          if [ ! -f "job_search/applications.json" ]; then
            echo "‚ö†Ô∏è No applications found to score"
            echo "high_score_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create preferences file if it doesn't exist
          if [ ! -f "configs/scoring_preferences.json" ]; then
            mkdir -p configs
            cat > configs/scoring_preferences.json << 'PREFS'
          {
            "salary_min": 50000,
            "salary_max": 150000,
            "locations": ["remote", "london", "uk"],
            "experience_level": "mid",
            "recency_days": 30,
            "weights": {
              "keywords": 40,
              "salary": 20,
              "location": 15,
              "company": 10,
              "experience": 10,
              "recency": 5
            }
          }
          PREFS
          fi
          
          # Run scoring with the configured CV path
          python3 .github/scripts/job_scorer.py \
          --cv "$CV_PATH" \
          --jobs job_search/applications.json \
          --output job_search/scored_jobs.json \
          --preferences configs/scoring_preferences.json \
          --min-score 70
          
          # Extract high score count from output file
          if [ -f "job_search/scored_jobs.json" ]; then
            HIGH_SCORE=$(python3 -c "
          import json
          try:
              with open('job_search/scored_jobs.json', 'r') as f:
                  data = json.load(f)
              # Handle both formats
              if isinstance(data, dict):
                  if 'filtered_jobs' in data:
                      print(data['filtered_jobs'])
                  elif 'jobs' in data:
                      jobs = data['jobs']
                      count = len([j for j in jobs if j.get('total_score', 0) >= 70])
                      print(count)
                  else:
                      print(0)
              elif isinstance(data, list):
                  count = len([j for j in data if j.get('total_score', 0) >= 70])
                  print(count)
              else:
                  print(0)
          except Exception as e:
              print(f'Error: {e}', file=__import__('sys').stderr)
              print(0)
          ")
            echo "high_score_count=$HIGH_SCORE" >> $GITHUB_OUTPUT
            echo "‚úÖ Found $HIGH_SCORE high-quality matches (score ‚â• 70)"
          else
            echo "‚ö†Ô∏è No scored jobs file created"
            echo "high_score_count=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit scored results
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          if [ -f "job_search/scored_jobs.json" ]; then
            git add job_search/scored_jobs.json
            git add configs/scoring_preferences.json
            git commit -m "üéØ Scored jobs: ${{ steps.score.outputs.high_score_count }} high-quality matches" || true
            git push || true
          else
            echo "‚ö†Ô∏è No changes to commit"
          fi

  # ========================================
  # NEW: AI COVER LETTER GENERATION
  # ========================================
  ai-cover-letters:
    name: Generate AI Cover Letters
    runs-on: ubuntu-latest
    needs: [coordinator, job-scoring]
    if: needs.job-scoring.outputs.high_score_count > 0
    
    outputs:
      letters_generated: ${{ steps.generate.outputs.count }}
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install OpenAI
        run: pip install openai
      
      - name: Generate cover letters
        id: generate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          python3 scripts/cover_letter_generator.py \
            --jobs job_search/scored_jobs.json \
            --cv cv/my_cv.txt \
            --output-dir job_search/cover_letters \
            --max-count 20
          
          COUNT=$(ls job_search/cover_letters/*.txt 2>/dev/null | wc -l)
          echo "count=$COUNT" >> $GITHUB_OUTPUT
      
      - name: Commit cover letters
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add cover_letter/
          git commit -m "üìù Generated ${{ steps.generate.outputs.count }} AI cover letters" || true
          git push || true
  # ========================================
  # STAGE 3.5: JOB SCORING
  # ========================================
  score-jobs:
    name: Score Discovered Jobs
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-matching]
    if: |
      always() &&
      needs.coordinator.outputs.run_matching == 'true' &&
      needs.trigger-matching.result == 'success'
    
    outputs:
      total_scored: ${{ steps.score.outputs.total_scored }}
      top_score: ${{ steps.score.outputs.top_score }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Score all discovered jobs
        id: score
        run: |
          echo "üéØ Scoring discovered jobs..."
          
          python3 .github/scripts/job_scorer.py \
            --cv cv/my_cv.txt \
            --jobs job_search/discovered_jobs.json \
            --output job_search/matched_jobs_scored.json \
            --preferences configs/scoring_preferences.json \
            --min-score 70
          
          # Extract stats
          TOTAL=$(jq '.total_jobs' job_search/matched_jobs_scored.json)
          TOP=$(jq '.top_matches[0].total_score' job_search/matched_jobs_scored.json)
          
          echo "total_scored=$TOTAL" >> $GITHUB_OUTPUT
          echo "top_score=$TOP" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Scored $TOTAL jobs, top score: $TOP"

      - name: Commit scored jobs
        uses: ./.github/actions/safe-git-push
        with:
          commit-message: "üéØ Job scoring complete: ${{ steps.score.outputs.total_scored }} matches"
          files: "job_search/*_scored.json"    
             
  # ========================================
  # STAGE 4: EMAIL NOTIFICATIONS
  # ========================================
  trigger-emails:
    name: Send Email Notifications
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-matching, score-jobs]  # Added score-jobs
    if: |
      always() &&
      needs.coordinator.outputs.run_emails == 'true' &&
      needs.score-jobs.result == 'success' &&  
      github.event.inputs.send_emails != 'false'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Trigger Email Sender
        run: |
          echo "üìß Triggering email notifications..."
          
          gh workflow run send-cv-match-emails.yml
          
          echo "‚úÖ Email workflow triggered"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Wait for Email Completion
        run: |
          echo "‚è≥ Waiting for emails to send..."
          sleep 20
          
          echo "üìä Recent email workflow runs:"
          gh run list --workflow=send-cv-match-emails.yml --limit=3 --json status,conclusion,createdAt \
            --jq '.[] | "\(.createdAt) - \(.status) - \(.conclusion // "pending")"'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# ========================================
# STAGE 5: APPLICATION PACKAGE GENERATION
# ========================================
  generate-packages:
    name: Generate Application Packages
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-matching]
    if: |
      always() &&
      needs.coordinator.outputs.run_matching == 'true' &&
      needs.trigger-matching.result == 'success'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Validate required files
        run: |
          echo "üîç Validating required files..."
          echo "================================"
    
          CV_PATH="${{ env.CV_FILE }}"
          COVER_LETTER_PATH="${{ env.COVER_LETTER_FILE }}"
    
          # Check for CV with flexible extensions
          if [ -f "$CV_PATH" ]; then
             echo "‚úÖ CV found: $CV_PATH"
             CV_EXT="${CV_PATH##*.}"
             echo "   Format: .$CV_EXT"
      
             # Validate CV format
             case "$CV_EXT" in
                 pdf|PDF)
                   echo "   ‚úÖ PDF format supported"
                   ;;
                 docx|DOCX|doc|DOC)
                    echo "   ‚úÖ Word format supported"
                    ;;
                 txt|TXT)
                     echo "   ‚úÖ Text format supported"
                     ;;
                  *)
                     echo "   ‚ö†Ô∏è  Warning: Unusual format (.$CV_EXT) - may need conversion"
                     ;;
             esac
          else
             echo "‚ùå CV file not found at: $CV_PATH"
             echo ""
             echo "Available CV files:"
             find cv/ -type f 2>/dev/null || echo "  (cv/ directory not found)"
             exit 1
          fi
    
          echo ""
    
          # Check for cover letter (optional with auto-creation)
          if [ -f "$COVER_LETTER_PATH" ]; then
             echo "‚úÖ Cover letter found: $COVER_LETTER_PATH"
             COVER_EXT="${COVER_LETTER_PATH##*.}"
             echo "   Format: .$COVER_EXT"
          else
             echo "‚ö†Ô∏è  Cover letter not found at: $COVER_LETTER_PATH"
             echo "‚ÑπÔ∏è  Creating placeholder cover letter..."
      
             # Create directory if needed
             mkdir -p "$(dirname "$COVER_LETTER_PATH")"
      
             # Determine format from extension
             COVER_EXT="${COVER_LETTER_PATH##*.}"
      
             case "$COVER_EXT" in
                 txt|TXT)
                     # Create text cover letter
                     cat > "$COVER_LETTER_PATH" << 'EOF'
          Dear Hiring Manager,
          
          I am writing to express my strong interest in the [POSITION] position at [COMPANY].

          [This is a placeholder cover letter. Please customize for each application or enable AI generation.]
                     
          With my background and skills outlined in my CV, I am confident I would be a valuable addition to your team.
        
          Best regards,
          [Your Name]
          EOF
          echo "‚úÖ Created text placeholder: $COVER_LETTER_PATH"
          ;;
        
                 pdf|PDF|docx|DOCX)
                    # For binary formats, create a text version first
                    TXT_PATH="${COVER_LETTER_PATH%.*}.txt"
                    cat > "$TXT_PATH" << 'EOF'
          Dear Hiring Manager,

          I am writing to express my strong interest in the [POSITION] position at [COMPANY].

          [This is a placeholder cover letter. Please customize for each application or enable AI generation.]

          With my background and skills outlined in my CV, I am confident I would be a valuable addition to your team.

          Best regards,
          [Your Name]
          EOF
          echo "‚úÖ Created text placeholder: $TXT_PATH"
          echo "‚ö†Ô∏è  Note: Requested .$COVER_EXT format - created .txt instead"
          echo "   You can convert it manually or use AI generation"
          ;;
        
                 *)
                    echo "‚ùå Unknown cover letter format: .$COVER_EXT"
                    echo "   Supported formats: .txt, .pdf, .docx"
                    exit 1
                    ;;
             esac
          fi
    
          echo ""
          echo "================================"
    
          # Check for matched jobs
          if [ ! -f "${{ env.DATA_DIR }}/matched_jobs.json" ]; then
             echo "‚ö†Ô∏è  No matched jobs found - skipping package generation"
             echo "skip_generation=true" >> $GITHUB_ENV
             exit 0
          fi
    
          echo "‚úÖ All required files validated"
      
      - name: Create packages for matched jobs
        if: env.skip_generation != 'true'
        run: |
          python3 << 'EOF'
          import sys
          import json
          import hashlib
          from pathlib import Path
          from datetime import datetime
          
          # Add scripts directory to path (standardized location)
          sys.path.insert(0, '.github/scripts')
          
          print("="*70)
          print("üì¶ GENERATING APPLICATION PACKAGES")
          print("="*70)
          
          # Import required modules
          try:
              from application_prefiller import ApplicationPrefiller
              from application_tracker import ApplicationTracker
              print("‚úÖ Modules imported successfully")
          except ImportError as e:
              print(f"‚ùå Failed to import required modules: {e}")
              print("üìç Looking in: .github/scripts/")
              sys.exit(1)
          
          def generate_job_id(job):
              """Generate consistent job ID from job data"""
              # Use existing ID if available
              if job.get('id'):
                  return str(job['id'])
              
              # Generate hash-based ID from job details
              job_string = f"{job.get('company', '')}_{job.get('title', '')}_{job.get('location', '')}"
              job_hash = hashlib.md5(job_string.encode()).hexdigest()[:12]
              return f"job_{job_hash}"


          # Get file paths from environment variables
          cv_path = Path('${{ env.CV_FILE }}')
          cover_letter_path = Path('${{ env.COVER_LETTER_FILE }}')

          print(f"\nüìÑ File Configuration:")
          print(f"   CV: {cv_path}")
          print(f"   Cover Letter: {cover_letter_path}")


          # Validate CV exists
          if not cv_path.exists():
             print(f"\n‚ùå CV not found at: {cv_path}")
             print("\nAvailable files in cv/:")
             cv_dir = Path('cv')
             if cv_dir.exists():
                 for file in cv_dir.iterdir():
                     print(f"   - {file}")
             sys.exit(1)

          print(f"‚úÖ CV found: {cv_path} ({cv_path.stat().st_size} bytes)")

          # Handle cover letter (with fallback)
          if not cover_letter_path.exists():
            print(f"‚ö†Ô∏è  Cover letter not found at: {cover_letter_path}")
    
            # Try to find alternative cover letter
            cover_dir = cover_letter_path.parent
            if cover_dir.exists():
               alt_covers = list(cover_dir.glob('*'))
               if alt_covers:
                   print(f"üìã Found alternative cover letters:")
                   for alt in alt_covers:
                        print(f"   - {alt}")
                   # Use the first one found
                   cover_letter_path = alt_covers[0]
                   print(f"‚úÖ Using: {cover_letter_path}")
               else:
                   print("‚ÑπÔ∏è  Creating placeholder cover letter")
                   cover_letter_path.parent.mkdir(parents=True, exist_ok=True)
                   cover_letter_path.write_text("Generic cover letter - customize per application")
            else:
              print("‚ÑπÔ∏è  Creating cover letter directory and placeholder")
              cover_letter_path.parent.mkdir(parents=True, exist_ok=True)
              cover_letter_path.write_text("Generic cover letter - customize per application")

          print(f"‚úÖ Cover letter: {cover_letter_path} ({cover_letter_path.stat().st_size} bytes)")
          print()

          # Load matched jobs
          matched_file = Path('${{ env.DATA_DIR }}/matched_jobs.json')
          
          with open(matched_file, 'r') as f:
              matched_jobs = json.load(f)
          
          print(f"\nüìä Processing {len(matched_jobs)} matched jobs")
          
          # Initialize prefiller and tracker
          try:
              prefiller = ApplicationPrefiller()
              tracker = ApplicationTracker('${{ env.DATA_DIR }}')
              print("‚úÖ ApplicationPrefiller and Tracker initialized")
          except Exception as e:
              print(f"‚ùå Failed to initialize components: {e}")
              import traceback
              traceback.print_exc()
              sys.exit(1)
          
          packages_created = 0
          packages_failed = 0
          results = []
          
          for idx, job in enumerate(matched_jobs, 1):
              job_id = generate_job_id(job)
              company = job.get('company', 'Unknown Company')
              title = job.get('title', 'Unknown Position')
              
              print(f"\n[{idx}/{len(matched_jobs)}] üì¶ Processing: {company} - {title}")
              print(f"   Job ID: {job_id}")
              
              try:
                  # Determine platform
                  platform = job.get('source', 'generic').lower()
                  valid_platforms = ['linkedin', 'indeed', 'reed', 'glassdoor']
                  if platform not in valid_platforms:
                      platform = 'generic'
                  
                  print(f"   Platform: {platform}")
                  
                  # Create package
                  package_dir = prefiller.create_application_package(
                      job_posting=job,
                      cv_path=str(cv_path),
                      cover_letter_path=str(cover_letter_path),
                      platform=platform
                  )
                  
                  if not package_dir:
                      raise ValueError("Package creation returned None")
                  
                  print(f"   ‚úÖ Package created at: {package_dir}")
                  
                  # Add to tracker
                  tracker.add_application(
                      job_id=job_id,
                      job_data=job,
                      platform=platform,
                      package_path=str(package_dir)
                  )
                  
                  # Update status with score information
                  score_info = f"CV: {job.get('cv_score', 'N/A')}, Match: {job.get('match_score', 'N/A')}"
                  tracker.update_status(
                      job_id=job_id,
                      status='package_created',
                      notes=f"Package generated successfully. Scores - {score_info}"
                  )
                  
                  packages_created += 1
                  results.append({
                      'job_id': job_id,
                      'company': company,
                      'title': title,
                      'status': 'success',
                      'package_path': str(package_dir)
                  })
                  
                  print(f"   ‚úÖ Tracking updated")
                  
              except Exception as e:
                  packages_failed += 1
                  error_msg = str(e)
                  print(f"   ‚ùå Error: {error_msg}")
                  
                  # Track failed attempt
                  try:
                      tracker.add_application(
                          job_id=job_id,
                          job_data=job,
                          platform=platform,
                          package_path=''
                      )
                      tracker.update_status(
                          job_id=job_id,
                          status='package_failed',
                          notes=f"Package generation failed: {error_msg}"
                      )
                  except:
                      pass
                  
                  results.append({
                      'job_id': job_id,
                      'company': company,
                      'title': title,
                      'status': 'failed',
                      'error': error_msg
                  })
                  
                  continue
          
          # Summary
          print("\n" + "="*70)
          print("üìä PACKAGE GENERATION SUMMARY")
          print("="*70)
          print(f"‚úÖ Successfully created: {packages_created}")
          print(f"‚ùå Failed: {packages_failed}")
          print(f"üì¶ Total processed: {len(matched_jobs)}")
          
          # Save tracker data
          try:
              tracker.save_applications()
              print("‚úÖ Application tracking data saved")
          except Exception as e:
              print(f"‚ö†Ô∏è Failed to save tracking data: {e}")
          
          # Generate and save report
          try:
              report = tracker.generate_report()
              report_file = Path('${{ env.DATA_DIR }}/reports/tracker_report.md')
              report_file.parent.mkdir(parents=True, exist_ok=True)
              
              with open(report_file, 'w') as f:
                  f.write(report)
              
              print(f"‚úÖ Report saved to: {report_file}")
          except Exception as e:
              print(f"‚ö†Ô∏è Failed to generate report: {e}")
          
          # Save detailed results
          results_file = Path('${{ env.DATA_DIR }}/package_generation_results.json')
          with open(results_file, 'w') as f:
              json.dump({
                  'timestamp': datetime.now().isoformat(),
                  'total_jobs': len(matched_jobs),
                  'packages_created': packages_created,
                  'packages_failed': packages_failed,
                  'results': results
              }, f, indent=2)
          
          print(f"‚úÖ Detailed results saved to: {results_file}")
          print("="*70)
          
          # Exit with error if all packages failed
          if packages_created == 0 and len(matched_jobs) > 0:
              print("\n‚ùå All package generation attempts failed!")
              sys.exit(1)
          
          EOF
      
      - name: Commit packages and tracking data
        if: env.skip_generation != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Add all generated files
          git add ${{ env.DATA_DIR }}/application_packages/ 2>/dev/null || true
          git add ${{ env.DATA_DIR }}/applications.json 2>/dev/null || true
          git add ${{ env.DATA_DIR }}/analytics.json 2>/dev/null || true
          git add ${{ env.DATA_DIR }}/reports/ 2>/dev/null || true
          git add ${{ env.DATA_DIR }}/package_generation_results.json 2>/dev/null || true
          
          # Commit with timestamp
          TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')
          git commit -m "üì¶ Application packages generated - $TIMESTAMP" || {
            echo "Nothing to commit"
            exit 0
          }
          
          # Push with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push; then
              echo "‚úÖ Changes pushed successfully"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 2
                git pull --rebase
              else
                echo "‚ùå Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi

          done

      
  # ========================================
  # STAGE 5: MAINTENANCE
  # ========================================
  trigger-maintenance:
    name: Run Maintenance
    runs-on: ubuntu-latest
    needs: coordinator
    if: needs.coordinator.outputs.run_maintenance == 'true'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Trigger Cleanup
        run: |
          echo "üßπ Triggering maintenance cleanup..."
          
          gh workflow run cleanup-old-workflows.yml
          
          echo "‚úÖ Cleanup workflow triggered"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ========================================
  # STAGE 6: MONITORING & REPORTING
  # ========================================
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [coordinator, trigger-discovery, trigger-matching, trigger-emails]
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Generate Pipeline Report
        run: |
          python3 << 'EOF'
          import json
          from datetime import datetime
          
          print("\n" + "="*80)
          print("JOB SEARCH PIPELINE SUMMARY")
          print("="*80)
          print(f"\nüìä Pipeline ID: ${{ needs.coordinator.outputs.pipeline_id }}")
          print(f"‚è∞ Timestamp: ${{ needs.coordinator.outputs.timestamp }}")
          print(f"üéØ Mode: ${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}")
          
          print("\nüìà STAGE RESULTS:")
          print(f"  Discovery:    ${{ needs.trigger-discovery.result || 'skipped' }}")
          print(f"  Matching:     ${{ needs.trigger-matching.result || 'skipped' }}")
          print(f"  Emails:       ${{ needs.trigger-emails.result || 'skipped' }}")
          
          print("\nüíæ DATA DIRECTORY: ${{ env.DATA_DIR }}")
          print("\n‚ÑπÔ∏è  NOTE: All workflows triggered with their default configurations")
          print("="*80)
          EOF
      
      - name: Create Summary Issue
        if: |
          github.event_name == 'schedule' ||
          github.event.inputs.pipeline_mode == 'full_pipeline'
        uses: actions/github-script@v7
        with:
          script: |
            const pipelineId = '${{ needs.coordinator.outputs.pipeline_id }}';
            const timestamp = '${{ needs.coordinator.outputs.timestamp }}';
            const mode = '${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}';
            
            const discoveryResult = '${{ needs.trigger-discovery.result || 'skipped' }}';
            const matchingResult = '${{ needs.trigger-matching.result || 'skipped' }}';
            const emailsResult = '${{ needs.trigger-emails.result || 'skipped' }}';
            
            const statusEmoji = {
              'success': '‚úÖ',
              'failure': '‚ùå',
              'skipped': '‚è≠Ô∏è'
            };
            
            const body = `# Job Search Pipeline Summary
            
            **Pipeline ID:** ${pipelineId}  
            **Timestamp:** ${timestamp}  
            **Mode:** ${mode}
            
            ## Stage Results
            
            | Stage | Status |
            |-------|--------|
            | Discovery | ${statusEmoji[discoveryResult]} ${discoveryResult} |
            | Matching | ${statusEmoji[matchingResult]} ${matchingResult} |
            | Emails | ${statusEmoji[emailsResult]} ${emailsResult} |
            
            ## Workflow Links
            
            - [Job Discovery](${{ github.server_url }}/${{ github.repository }}/actions/workflows/job-discovery-worker.yml)
            - [CV Matcher](${{ github.server_url }}/${{ github.repository }}/actions/workflows/cv_job_matcher.yml)
            - [Email Sender](${{ github.server_url }}/${{ github.repository }}/actions/workflows/send-cv-match-emails.yml)
            
            ## Configuration Note
            
            All workflows were triggered with their default configurations.  
            To customize behavior, configure each workflow directly.
            
            ---
            [View This Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üìä Pipeline Summary - ${pipelineId}`,
              body: body,
              labels: ['job-search', 'pipeline-summary', 'automated']
            });
      
      - name: Send Slack Notification
        if: vars.SLACK_WEBHOOK_URL != ''
        run: |
          python3 << 'EOF'
          import requests
          import json
          
          webhook_url = "${{ vars.SLACK_WEBHOOK_URL }}"
          
          discovery = "${{ needs.trigger-discovery.result || 'skipped' }}"
          matching = "${{ needs.trigger-matching.result || 'skipped' }}"
          emails = "${{ needs.trigger-emails.result || 'skipped' }}"
          
          status_emoji = {
              'success': '‚úÖ',
              'failure': '‚ùå',
              'skipped': '‚è≠Ô∏è'
          }
          
          message = {
              "text": "ü§ñ Job Search Pipeline Complete",
              "blocks": [
                  {
                      "type": "header",
                      "text": {
                          "type": "plain_text",
                          "text": "ü§ñ Job Search Pipeline Summary"
                      }
                  },
                  {
                      "type": "section",
                      "fields": [
                          {
                              "type": "mrkdwn",
                              "text": f"*Pipeline ID:*\n${{ needs.coordinator.outputs.pipeline_id }}"
                          },
                          {
                              "type": "mrkdwn",
                              "text": f"*Mode:*\n${{ github.event.inputs.pipeline_mode || 'full_pipeline' }}"
                          }
                      ]
                  },
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*Results:*\n{status_emoji[discovery]} Discovery\n{status_emoji[matching]} Matching\n{status_emoji[emails]} Emails"
                      }
                  }
              ]
          }
          
          if webhook_url:
              response = requests.post(webhook_url, json=message)
              print(f"Notification sent: {response.status_code}")
          EOF      

      - name: Validate applications data
        run: |
          python3 << 'EOF'
          import json
          from pathlib import Path
    
          apps_file = Path('${{ env.DATA_DIR }}/applications.json')
    
          if not apps_file.exists():
             print("‚ÑπÔ∏è  No applications.json found - creating empty structure")
             apps_file.parent.mkdir(parents=True, exist_ok=True)
             with open(apps_file, 'w') as f:
                   json.dump([], f)
             exit(0)
    
          # Load and validate
          with open(apps_file, 'r') as f:
               data = json.load(f)
    
          # Normalize to list
          if isinstance(data, dict):
                if 'applications' in data:
                    apps = data['applications']
                else:
                    apps = [data]
          elif isinstance(data, list):
                    apps = data
          else:
                 print("‚ùå Invalid format - resetting")
                 apps = []
    
          # Validate each app has required fields
          required = ['id', 'status', 'company', 'position']
          valid_apps = []
    
          for app in apps:
                if all(field in app for field in required):
                     # Ensure all optional fields exist
                     app.setdefault('submitted_at', None)
                     app.setdefault('follow_ups', [])
                     app.setdefault('reminders', [])
                     app.setdefault('status_history', [])
                     valid_apps.append(app)
                else:
                       print(f"‚ö†Ô∏è  Skipping invalid app: {app.get('id', 'unknown')}")
    
          # Save cleaned data
          with open(apps_file, 'w') as f:
                 json.dump(valid_apps, f, indent=2)
    
          print(f"‚úÖ Validated {len(valid_apps)} applications")
          EOF
  # ========================================
  # STAGE 6: FOLLOW-UP MANAGEMENT
  # ========================================
  manage-followups:
    name: Manage Follow-ups
    runs-on: ubuntu-latest
    needs: [coordinator, generate-packages]
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Check and create follow-up reminders
        id: followups
        run: |
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.github/scripts')
          
          from application_tracker_plus import ApplicationTracker
          import json
          
          print("="*70)
          print("üì¨ CHECKING FOLLOW-UPS")
          print("="*70)
          
          tracker = ApplicationTracker()
          
          # Get follow-ups needed
          follow_ups = tracker.get_follow_up_needed()
          
          print(f"\nüìä Found {len(follow_ups)} applications needing follow-up")
          
          if follow_ups:
              print("\nüìã Follow-up List:")
              for fu in follow_ups:
                  print(f"  ‚Ä¢ {fu['company']} - {fu['position']}")
                  print(f"    Days since submission: {fu['days_since_submission']}")
                  print(f"    Priority: {fu['priority']}")
                  print()
          
          # Get due reminders
          reminders = tracker.get_due_reminders()
          
          print(f"\n‚è∞ Found {len(reminders)} due reminders")
          
          if reminders:
              print("\nüìã Due Reminders:")
              for r in reminders:
                  print(f"  ‚Ä¢ {r['company']} - {r['position']}")
                  print(f"    {r['reminder']['message']}")
                  print()
          
          # Save to file for email
          followup_data = {
              'follow_ups': follow_ups,
              'reminders': reminders
          }
          
          with open('followup_data.json', 'w') as f:
              json.dump(followup_data, f, indent=2)
          
          # Set outputs
          import os
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"followups_count={len(follow_ups)}\n")
              f.write(f"reminders_count={len(reminders)}\n")
          
          print("="*70)
          EOF
      
      - name: Create follow-up issue
        if: steps.followups.outputs.followups_count > 0
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('followup_data.json', 'utf8'));
            
            let body = `# Follow-up Required\n\n`;
            body += `**Date:** ${new Date().toISOString().split('T')[0]}\n\n`;
            body += `## Applications Needing Follow-up (${data.follow_ups.length})\n\n`;
            
            for (const fu of data.follow_ups) {
              body += `### ${fu.company} - ${fu.position}\n`;
              body += `- **Days Since Submission:** ${fu.days_since_submission}\n`;
              body += `- **Action:** ${fu.action}\n`;
              body += `- **Priority:** ${fu.priority}\n\n`;
            }
            
            if (data.reminders.length > 0) {
              body += `## Due Reminders (${data.reminders.length})\n\n`;
              for (const r of data.reminders) {
                body += `### ${r.company} - ${r.position}\n`;
                body += `- **Reminder:** ${r.reminder.message}\n`;
                body += `- **Due:** ${r.reminder.due_date}\n\n`;
              }
            }
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üì¨ Follow-up Needed (${data.follow_ups.length} applications)`,
              body: body,
              labels: ['follow-up', 'applications', 'automation']
            });
            
            console.log('‚úÖ Follow-up issue created successfully');

      - name: Upload follow-up summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: follow-up-summary-${{ github.run_number }}
          path: followup_data.json
          retention-days: 14

  # ========================================
  # STAGE 7: STATUS MANAGEMENT & TRACKING
  # ========================================
  manage-application-status:
    name: Update Application Statuses
    runs-on: ubuntu-latest
    needs: [coordinator, generate-packages]
    if: |
      always() &&
      needs.create-packages.result == 'success'
    
    outputs:
      status_updates: ${{ steps.status_update.outputs.updates_count }}
      reminders_created: ${{ steps.status_update.outputs.reminders_count }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Auto-update application statuses
        id: status_update
        run: |
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.github/scripts')
          
          from update_application_status import ApplicationStatusUpdater
          from application_tracker_plus import ApplicationTracker
          
          print("="*70)
          print("√∞≈∏"‚Äû AUTO-UPDATING APPLICATION STATUSES")
          print("="*70)
          
          updater = ApplicationStatusUpdater('${{ env.DATA_DIR }}')
          tracker = ApplicationTracker('${{ env.DATA_DIR }}')
          
          updates_count = 0
          reminders_count = 0
          
          # Auto-transition: package_created -> in_progress
          package_created_apps = tracker.get_applications_by_status('package_created')
          print(f"\n√∞≈∏"¬¶ Found {len(package_created_apps)} applications with packages")
          
          for app in package_created_apps:
              # Check if package was created recently (within last hour)
              from datetime import datetime, timedelta
              last_updated = datetime.fromisoformat(app['last_updated'])
              if datetime.now() - last_updated < timedelta(hours=1):
                  success = tracker.update_status(
                      app['id'],
                      'in_progress',
                      'Package ready - ready for application submission',
                      auto_reminders=True
                  )
                  if success:
                      updates_count += 1
                      print(f"   √¢≈ì‚Ä¶ {app['company']} -> in_progress")
          
          # Auto-create reminders for submitted applications without reminders
          submitted_apps = tracker.get_applications_by_status('submitted')
          print(f"\n√∞≈∏"¬§ Checking {len(submitted_apps)} submitted applications for reminders")
          
          for app in submitted_apps:
              if not app.get('reminders'):
                  # Create default follow-up reminders
                  from datetime import datetime, timedelta
                  
                  # Day 3: Check status
                  tracker.add_reminder(
                      app['id'],
                      'Check application status',
                      (datetime.now() + timedelta(days=3)).isoformat(),
                      priority='medium'
                  )
                  
                  # Day 7: Follow-up email
                  tracker.add_reminder(
                      app['id'],
                      'Send follow-up email',
                      (datetime.now() + timedelta(days=7)).isoformat(),
                      priority='high'
                  )
                  
                  reminders_count += 2
                  print(f"   √¢≈ì‚Ä¶ {app['company']} - reminders created")
          
          print(f"\n√∞≈∏"≈† Status Update Summary:")
          print(f"   Status updates: {updates_count}")
          print(f"   Reminders created: {reminders_count}")
          
          # Set outputs
          import os
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"updates_count={updates_count}\n")
              f.write(f"reminders_count={reminders_count}\n")
          
          print("="*70)
          EOF
      
      - name: Commit status updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/applications.json
          git add ${{ env.DATA_DIR }}/analytics.json
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "√∞≈∏"‚Äû Auto-updated ${{ steps.status_update.outputs.updates_count }} application statuses"
          
          git push

  # ========================================
  # STAGE 8: FOLLOW-UP REMINDER MANAGEMENT
  # ========================================
  process-followup-reminders:
    name: Process Follow-up Reminders
    runs-on: ubuntu-latest
    needs: [coordinator, generate-packages]
    if: always()
    
    outputs:
      due_reminders: ${{ steps.reminders.outputs.due_count }}
      followups_needed: ${{ steps.reminders.outputs.followup_count }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Check due reminders and follow-ups
        id: reminders
        run: |
          python3 .github/scripts/github_actions_followup_manager.py \
            --mode report \
            --data-dir ${{ env.DATA_DIR }} \
            --days-ahead 7 \
            --output followup_report.json
          
          DUE=$(jq '.summary.due_reminders' followup_report.json)
          FOLLOWUPS=$(jq '.summary.follow_ups_needed' followup_report.json)
          
          echo "due_count=$DUE" >> $GITHUB_OUTPUT
          echo "followup_count=$FOLLOWUPS" >> $GITHUB_OUTPUT
          
          # Also export for email
          python3 .github/scripts/github_actions_followup_manager.py \
            --mode export \
            --data-dir ${{ env.DATA_DIR }} \
            --days-ahead 7 \
            --output followup_summary.json
          
      - name: Commit follow-up data
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ env.DATA_DIR }}/reports/followup_report.txt
          git add ${{ env.DATA_DIR }}/reminders_calendar.ics
          
          git diff --quiet && git diff --staged --quiet || \
            git commit -m "√¢¬∞ Follow-up report: ${{ steps.reminders.outputs.due_count }} reminders due"
          
          git push
      
      - name: Upload follow-up summary
        uses: actions/upload-artifact@v4
        with:
          name: followup-summary-${{ github.run_number }}
          path: |
            followup_summary.json
            ${{ env.DATA_DIR }}/reports/followup_report.txt
            ${{ env.DATA_DIR }}/reminders_calendar.ics
          retention-days: 30

  validate-integration:
    name: Validate Script Integration
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Test script imports
        run: |
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.github/scripts')
          
          try:
              from update_application_status import ApplicationStatusUpdater, GitHubActionsUpdater
              print("update_application_status.py imported successfully")
          except Exception as e:
              print(f"Failed to import update_application_status.py: {e}")
              sys.exit(1)
          
          try:
              from follow_up_remainders import FollowUpManager, GitHubActionsFollowUpManager
              print("follow_up_remainders.py imported successfully")
          except Exception as e:
              print(f"Failed to import follow_up_remainders.py: {e}")
              sys.exit(1)
          
          try:
              from github_actions_status_updater import main as status_main
              print("github_actions_status_updater.py imported successfully")
          except Exception as e:
              print(f"Failed to import github_actions_status_updater.py: {e}")
              sys.exit(1)
          
          try:
              from github_actions_followup_manager import main as followup_main
              print("github_actions_followup_manager.py imported successfully")
          except Exception as e:
              print(f"Failed to import github_actions_followup_manager.py: {e}")
              sys.exit(1)
          
          print("\n√¢≈ì‚Ä¶ All integrations validated successfully!")
          EOF

  
  # ========================================
  # STAGE 9: ENHANCED EMAIL NOTIFICATIONS
  # ========================================
  send-enhanced-notifications:
    name: Send Enhanced Email Notifications
    runs-on: ubuntu-latest
    needs: [coordinator, process-followup-reminders, score-jobs]
    if: |
      always() &&
      needs.coordinator.outputs.run_emails == 'true' &&
      github.event.inputs.send_emails != 'false'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Download artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: followup-summary-${{ github.run_number }}
      
      - name: Send comprehensive email notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.SMTP_USER }}
          password: ${{ secrets.SMTP_PASS }}
          subject: "√∞≈∏≈°‚Ç¨ Job Search Pipeline Complete | √¢¬∞ ${{ needs.process-followup-reminders.outputs.due_reminders }} Reminders | √∞≈∏≈Ω¬Ø ${{ needs.score-jobs.outputs.total_scored }} Matches"
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: Job Search Automation <${{ secrets.SMTP_USER }}>
          html_body: |
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                .container { max-width: 700px; margin: 0 auto; padding: 20px; }
                .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px; }
                .section { background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 8px; border-left: 4px solid #667eea; }
                .alert { background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0; border-radius: 5px; }
                .critical { background: #f8d7da; border-left: 4px solid #dc3545; }
                .success { background: #d4edda; border-left: 4px solid #28a745; }
                .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0; }
                .stat-card { background: white; padding: 15px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                .stat-number { font-size: 32px; font-weight: bold; color: #667eea; }
                .stat-label { color: #666; font-size: 14px; }
                .reminder-item { background: white; padding: 12px; margin: 8px 0; border-radius: 5px; border-left: 3px solid #ffc107; }
                .followup-item { background: white; padding: 12px; margin: 8px 0; border-radius: 5px; border-left: 3px solid #17a2b8; }
                .priority-high { border-left-color: #dc3545; }
                .priority-critical { border-left-color: #721c24; background: #f8d7da; }
                table { width: 100%; border-collapse: collapse; margin: 15px 0; }
                th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
                th { background: #667eea; color: white; }
                .btn { display: inline-block; padding: 12px 24px; background: #667eea; color: white; text-decoration: none; border-radius: 5px; margin: 10px 5px; }
                .footer { margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd; font-size: 12px; color: #666; text-align: center; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>√∞≈∏≈°‚Ç¨ Job Search Pipeline Complete</h1>
                  <p>Execution completed on $(date +'%Y-%m-%d at %H:%M UTC')</p>
                </div>

                <div class="stats-grid">
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.score-jobs.outputs.total_scored }}</div>
                    <div class="stat-label">High-Quality Matches</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.manage-application-status.outputs.status_updates }}</div>
                    <div class="stat-label">Status Updates</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.process-followup-reminders.outputs.due_reminders }}</div>
                    <div class="stat-label">Due Reminders</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-number">${{ needs.process-followup-reminders.outputs.followups_needed }}</div>
                    <div class="stat-label">Follow-ups Needed</div>
                  </div>
                </div>

                <div class="section">
                  <h2>√¢¬∞ Action Required: Due Reminders</h2>
                  <p><strong>${{ needs.process-followup-reminders.outputs.due_reminders }}</strong> reminders need your attention</p>
                  
                  <div class="alert critical">
                    <strong>√¢≈° √Ø¬∏  Check Today:</strong> Review reminders marked as critical or high priority
                  </div>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/reports/followup_report.txt" class="btn">
                    View Full Reminder Report
                  </a>
                </div>

                <div class="section">
                  <h2>√∞≈∏"≈æ Follow-up Actions</h2>
                  <p><strong>${{ needs.process-followup-reminders.outputs.followups_needed }}</strong> applications need follow-up</p>
                  
                  <div class="alert">
                    <strong>√∞≈∏'¬° Tip:</strong> Applications older than 7 days without response should be followed up
                  </div>
                </div>

                <div class="section success">
                  <h2>√∞≈∏≈Ω¬Ø High-Quality Job Matches</h2>
                  <p>Found <strong>${{ needs.score-jobs.outputs.total_scored }}</strong> jobs matching your criteria (70+ score)</p>
                  <p>Top match score: <strong>${{ needs.score-jobs.outputs.top_score }}%</strong></p>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/blob/main/${{ env.DATA_DIR }}/matched_jobs_scored.json" class="btn">
                    View Scored Jobs
                  </a>
                </div>

                <div class="section">
                  <h2>√∞≈∏"¬¶ Application Packages</h2>
                  <p>Ready-to-submit application packages have been created</p>
                  
                  <h3>Next Steps:</h3>
                  <ol>
                    <li>Review due reminders (see calendar attachment)</li>
                    <li>Send follow-up emails for overdue applications</li>
                    <li>Submit applications from ready packages</li>
                    <li>Update statuses as you progress</li>
                  </ol>
                  
                  <a href="${{ github.server_url }}/${{ github.repository }}/tree/main/${{ env.DATA_DIR }}/application_packages" class="btn">
                    View All Packages
                  </a>
                </div>

                <div class="section">
                  <h2>√∞≈∏"≈† Pipeline Summary</h2>
                  <table>
                    <tr>
                      <th>Stage</th>
                      <th>Status</th>
                    </tr>
                    <tr>
                      <td>Job Discovery</td>
                      <td>√¢≈ì‚Ä¶ Complete</td>
                    </tr>
                    <tr>
                      <td>Job Scoring</td>
                      <td>√¢≈ì‚Ä¶ ${{ needs.score-jobs.outputs.total_scored }} matches</td>
                    </tr>
                    <tr>
                      <td>Package Creation</td>
                      <td>√¢≈ì‚Ä¶ Complete</td>
                    </tr>
                    <tr>
                      <td>Status Updates</td>
                      <td>√¢≈ì‚Ä¶ ${{ needs.manage-application-status.outputs.status_updates }} updates</td>
                    </tr>
                    <tr>
                      <td>Reminders</td>
                      <td>√¢¬∞ ${{ needs.process-followup-reminders.outputs.due_reminders }} due</td>
                    </tr>
                  </table>
                </div>

                <div class="footer">
                  <p><strong>√∞≈∏"‚Ä¶ Calendar Attached:</strong> Import reminders_calendar.ics into your calendar app</p>
                  <p><strong>√∞≈∏"‚Äû Full Report:</strong> Check the followup_report.txt attachment</p>
                  <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Workflow Logs</a></p>
                  <p>Automated by Job Search Orchestrator</p>
                </div>
              </div>
            </body>
            </html>
          attachments: |
            followup_summary.json
            ${{ env.DATA_DIR }}/reports/followup_report.txt
            ${{ env.DATA_DIR }}/reminders_calendar.ics
